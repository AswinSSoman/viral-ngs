
import copy
# imports needed for download_file() and webfile_readlines()
import re
# since py3 split up urllib
try:
    from urllib.request import urlopen
except ImportError:
    from urllib2 import urlopen
shell.executable("/bin/bash")

def set_env_vars():
    import os
    for k,v in config.get('env_vars', {}).items():
        if k not in os.environ:
            os.environ[k] = v

def read_tab_file(fname):
    with open(fname, 'rt') as inf:
        header = [item.strip() for item in inf.readline().strip().rstrip('\n').split('\t')]
        for line in inf:
            row = [item.strip() for item in line.rstrip('\n').split('\t')]
            if len(row) > len(header):
                # truncate the row to the header length, and only include extra items if they are not spaces 
                # (takes care of the case where the user may enter an extra space at the end of a row)
                row = row[:len(header)] + [item for item in row[len(header):] if len(item)]
            assert len(header) == len(row)
            yield dict(zip(header, row))

def read_samples_file(fname, number_of_chromosomes=1, append_chrom_num=False):
    if fname==None:
        return []
    with open(fname, 'rt') as inf:
        for line in inf:
            if not append_chrom_num:
                yield line.strip()
            else:
                line = line.strip()
                for i in range(1, number_of_chromosomes+1):
                    yield line+"-{idx}".format(idx=str(i))

def read_accessions_file(fname):
    if fname==None:
        return []
    with open(fname, 'rt') as inf:
        for line in inf:
            yield line.strip()

def download_file(uriToGet, dest, destFileName=None):
    destDir = os.path.realpath(os.path.expanduser(dest))

    req = urlopen(uriToGet)

    if not destFileName:
        m = re.search('filename="(?P<filename>.+)"', req.info()['Content-Disposition'])

        if m:
            destFileName = m.group("filename")
        else:
            destFileName = "file"

    destPath = os.path.join(destDir, destFileName)

    with open(destPath, "wb") as outf:
        while True:
           chunk = req.read(1024)
           if not chunk: break
           outf.write(chunk)

    return destPath

def webfile_readlines(uriToGet):

    for line in urlopen(uriToGet):#.readlines():
        cleanedLine = line.decode("utf-8").strip()
        if len(cleanedLine) > 0:
            yield cleanedLine

def process_cfg_includes(cfg, seen=None, std_include=None):
    '''Add bindings from any (nested) config includes.

    Args:
       cfg: a dictionary representing a config file. Can specify included config files via config entry
         'include_config', which can be a file or a list of files.  (Relative paths are interpreted
         relative to the current directory, not to the location of any config file).
         Bindings from cfg override any bindings from config files it includes.

       seen: set of config files already loaded (to catch circular includes)
       std_include: the standard config file from the viral-ngs code checkout, pipes/config.yaml .
    '''
    print('process_cfg_includes: cfg={} seen={} std_include={}'.format(cfg, seen, std_include))
    if seen is None: seen = set()
    seenOrig = copy.deepcopy(seen)
    result=dict()

    def make_list(x): return [x] if isinstance(x,str) else x

    def merge_dicts(old,new):
        """Return a new dict with entries from both dicts `old` and `new`. 
           If both have an entry, one from `new` is used."""
        result=dict()
        result.update(old)
        result.update(new)
        return result

    def do_update(old,new):
        """Merge two dicts, with entries from `new` taking priority.  If special entry `env_vars` exists in both,
        the two entries will be merged in the results, with `env_vars` mappings from `new` taking priority.
        """
        result = merge_dicts(old,new)
        if 'env_vars' in old and 'env_vars' in new:
            result['env_vars']=merge_dicts(old['env_vars'],new['env_vars'])
        return result

    cfg_includes=[]
    if std_include: cfg_includes += [std_include]
    cfg_includes += make_list(cfg.get('include_config', []))

    for incl_cfg in cfg_includes:
        assert os.path.isfile(incl_cfg), "Included config file does not exist: {}".format(incl_cfg)
        assert os.path.realpath(incl_cfg) not in seen, \
            "Circular config include: {} already seen (seen={})".format(incl_cfg,seen)
        seen.add(os.path.realpath(incl_cfg))
        result = do_update(result,load_cfg(incl_cfg, seen))

    result = do_update(result, cfg)
    return result
    

def load_cfg(f, seen):
    '''Load a config file, including any includes'''
    with open(f) as cfg_f:
        return process_cfg_includes(yaml.safe_load(cfg_f) or dict(), seen)


